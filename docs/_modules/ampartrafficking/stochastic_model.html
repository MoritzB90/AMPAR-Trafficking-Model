

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>ampartrafficking.stochastic_model &mdash; AMPAR-Trafficking-Model 02.11.2020 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> AMPAR-Trafficking-Model
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../code.html">Code documentation: ampartrafficking</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">AMPAR-Trafficking-Model</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>ampartrafficking.stochastic_model</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for ampartrafficking.stochastic_model</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Wed Nov  4 11:48:22 2020</span>

<span class="sd">@author: Moritz</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span>

<div class="viewcode-block" id="nearestNeighbours"><a class="viewcode-back" href="../../code.html#ampartrafficking.stochastic_model.nearestNeighbours">[docs]</a><span class="k">def</span> <span class="nf">nearestNeighbours</span><span class="p">(</span><span class="n">PSD</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the number of nearest neighbours on a grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    PSD : array_like</span>
<span class="sd">        Grid with occupied and free elements, shape(N, N)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: array_like</span>
<span class="sd">        Matrix containing the number of nearest neighbors for each element of the grid matrix.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Import libraries:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import ampartrafficking.stochastic_model as sm</span>
<span class="sd">    </span>
<span class="sd">    Create and populate grid and calculate nearest neighbour matrix:</span>

<span class="sd">    &gt;&gt;&gt; N=10</span>
<span class="sd">    &gt;&gt;&gt; PSD=np.zeros((N,N))</span>
<span class="sd">    &gt;&gt;&gt; PSD[np.random.randint(0,N,20),np.random.randint(0,N,20)]=1</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; NN=sm.nearestNeighbours(PSD)</span>
<span class="sd">    </span>
<span class="sd">    Plot:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(3,3), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(PSD)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(3,3), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(NN)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;position&#39;)</span>

<span class="sd">    Output:</span>
<span class="sd">        </span>
<span class="sd">    .. image:: images/example1_nearestNeighbours.png</span>
<span class="sd">        :width: 30%</span>
<span class="sd">    .. image:: images/example2_nearestNeighbours.png</span>
<span class="sd">        :width: 30%</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">n</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">PSD</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">m</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">PSD</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">PSD_border</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">));</span><span class="c1">#PSD_boarder is the matrix that contains PSD with the addition of one row or column to each border of PSD%</span>
    <span class="n">PSD_border</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">PSD</span><span class="o">!=</span><span class="mi">0</span><span class="p">;</span><span class="c1">#PSD also accounts for receptor types (bleached, not not bleached) such that occupied sites can have float values &gt;0. Therefore it has to be checked where PSD does not equal zero to genererate the matrix of occupied sites PSD_boarder.</span>
            
    <span class="n">PSD_up</span><span class="o">=</span><span class="n">PSD_border</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="c1"># The matrix PSD_up represent the number of occupied nearest neighbors up to each site. </span>
    <span class="n">PSD_down</span><span class="o">=</span><span class="n">PSD_border</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="c1"># The matrix PSD_down represent the number of occupied nearest neighbors down to each site.</span>
    <span class="n">PSD_left</span><span class="o">=</span><span class="n">PSD_border</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">];</span><span class="c1"># The matrix PSD_left represent the number of occupied nearest neighbors on the left to each site.</span>
    <span class="n">PSD_right</span><span class="o">=</span><span class="n">PSD_border</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="c1"># The matrix PSD_right represent the number of occupied nearest neighbors on the right of each site.</span>
    <span class="n">PSD_upright</span><span class="o">=</span><span class="n">PSD_border</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="c1"># The matrix PSD_upright represent the number of occupied nearest neighbors up-right to each site.</span>
    <span class="n">PSD_downleft</span><span class="o">=</span><span class="n">PSD_border</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">];</span><span class="c1"># The matrix PSD_downleft represent the number of occupied nearest neighbors down-left to each site.</span>
    <span class="n">PSD_downright</span><span class="o">=</span><span class="n">PSD_border</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">m</span><span class="o">+</span><span class="mi">2</span><span class="p">];</span><span class="c1"># The matrix PSD_downright represent the number of occupied nearest neighbors down-right to each site.</span>
    <span class="n">PSD_upleft</span><span class="o">=</span><span class="n">PSD_border</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">];</span><span class="c1"># The matrix PSD_upleft represent the number of occupied nearest neighbors up-left to each site.</span>
    
    <span class="n">NN</span><span class="o">=</span><span class="n">PSD_up</span><span class="o">+</span><span class="n">PSD_down</span><span class="o">+</span><span class="n">PSD_left</span><span class="o">+</span><span class="n">PSD_right</span><span class="o">+</span><span class="n">PSD_upright</span><span class="o">+</span><span class="n">PSD_downright</span><span class="o">+</span><span class="n">PSD_downleft</span><span class="o">+</span><span class="n">PSD_upleft</span><span class="p">;</span><span class="c1">#The matrix nearestNeighbors represents the total number of occupied nearest neighbors for each site.</span>
    
    <span class="k">return</span> <span class="n">NN</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>





<div class="viewcode-block" id="kBUcoop"><a class="viewcode-back" href="../../code.html#ampartrafficking.stochastic_model.kBUcoop">[docs]</a><span class="k">def</span> <span class="nf">kBUcoop</span><span class="p">(</span><span class="n">kBU</span><span class="p">,</span> <span class="n">NN</span><span class="p">,</span> <span class="n">PSD</span><span class="p">,</span> <span class="n">typeID</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;Returns the cooperative unbinding rate per bound receptor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kBU : float</span>
<span class="sd">        unbinding rate</span>
<span class="sd">    beta : float, optional</span>
<span class="sd">        By default beta=1.0. Factor by which the fraction of occupied nearest neighbours lowers the unbinding rate.</span>
<span class="sd">    NN : array_like</span>
<span class="sd">        Matrix that contains the number of nearest neighbours for each grid element.</span>
<span class="sd">    PSD : array_like</span>
<span class="sd">        Matrix representing the PSD grid</span>
<span class="sd">    typeID : float&gt;0</span>
<span class="sd">        Receptor-type ID.</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: array_like</span>
<span class="sd">        Matrix containing the unbinding rates at each occupied grid element.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Import libraries:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import ampartrafficking.stochastic_model as sm</span>
<span class="sd">    </span>
<span class="sd">    Create and populate grid and calculate nearest neighbour matrix:</span>

<span class="sd">    &gt;&gt;&gt; kBU=0.1</span>
<span class="sd">    &gt;&gt;&gt; typeID=2</span>
<span class="sd">    &gt;&gt;&gt; N=10</span>
<span class="sd">    &gt;&gt;&gt; PSD=np.zeros((N,N))</span>
<span class="sd">    &gt;&gt;&gt; PSD[np.random.randint(0,N,20),np.random.randint(0,N,20)]=typeID</span>
<span class="sd">    &gt;&gt;&gt; NN=sm.nearestNeighbours(PSD)</span>
<span class="sd">    </span>
<span class="sd">    Plot:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(4,3), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(sm.kBUcoop(kBU, np.arange(0,9), np.array([typeID]*9), typeID))</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;number of nearest neighbours&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;unbinding rate $k_{BU}^{coop}$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; fig=plt.figure(figsize=(3,2.25), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(PSD)</span>
<span class="sd">    &gt;&gt;&gt; cbar=plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; cbar.set_label(&#39;occupied (type)&#39;, rotation=90, labelpad=10, y=0.5)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; fig=plt.figure(figsize=(3,2.25), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(NN)</span>
<span class="sd">    &gt;&gt;&gt; cbar=plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; cbar.set_label(&#39;nearest neighbours&#39;, rotation=90, labelpad=10, y=0.5)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; fig=plt.figure(figsize=(3,2.25), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(sm.kBUcoop(kBU, NN, PSD, typeID))</span>
<span class="sd">    &gt;&gt;&gt; cbar=plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; cbar.set_label(&#39;unbinding rate $k_{BU}^{coop}$&#39;, rotation=90, labelpad=10, y=0.5)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;position&#39;)</span>

<span class="sd">    Output:</span>
<span class="sd">        </span>
<span class="sd">    .. image:: images/example1_kBUcoop.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    .. image:: images/example2_kBUcoop.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    .. image:: images/example3_kBUcoop.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    .. image:: images/example4_kBUcoop.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">M</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">PSD</span><span class="p">))</span>
    <span class="n">occupied</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">PSD</span><span class="o">==</span><span class="n">typeID</span><span class="p">)</span>
    <span class="n">Chi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span>
    <span class="n">M</span><span class="p">[</span><span class="n">occupied</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">kBU</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">Chi</span><span class="o">*</span><span class="n">beta</span><span class="p">))[</span><span class="n">NN</span><span class="p">])[</span><span class="n">occupied</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">M</span></div>





<div class="viewcode-block" id="kUBcoop"><a class="viewcode-back" href="../../code.html#ampartrafficking.stochastic_model.kUBcoop">[docs]</a><span class="k">def</span> <span class="nf">kUBcoop</span><span class="p">(</span><span class="n">kUB</span><span class="p">,</span> <span class="n">NN</span><span class="p">,</span> <span class="n">PSD</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;Returns the cooperative binding rate per mobile receptor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    kUB : float</span>
<span class="sd">        binding rate</span>
<span class="sd">    alpha : float, optional</span>
<span class="sd">        By default alpha=16. Factor by which the fraction of occupied nearest neighbours increases the binding rate.</span>
<span class="sd">    NN : array_like</span>
<span class="sd">        Matrix that contains the number of nearest neighbours for each grid element.</span>
<span class="sd">    PSD : array_like</span>
<span class="sd">        Matrix representing the PSD grid</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: array_like</span>
<span class="sd">        Matrix containing the binding rates at each unoccupied grid element.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Import libraries:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import ampartrafficking.stochastic_model as sm</span>
<span class="sd">    </span>
<span class="sd">    Create and populate grid and calculate nearest neighbour matrix:</span>

<span class="sd">    &gt;&gt;&gt; kUB=0.0005</span>
<span class="sd">    &gt;&gt;&gt; N=10</span>
<span class="sd">    &gt;&gt;&gt; PSD=np.zeros((N,N))</span>
<span class="sd">    &gt;&gt;&gt; PSD[np.random.randint(0,N,20),np.random.randint(0,N,20)]=1</span>
<span class="sd">    &gt;&gt;&gt; NN=sm.nearestNeighbours(PSD)</span>
<span class="sd">    </span>
<span class="sd">    Plot:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; plt.figure(figsize=(4,3), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(sm.kUBcoop(kUB, np.arange(0,9), np.array([0]*9)))</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;number of nearest neighbours&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;binding rate $k_{UB}^{coop}$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; fig=plt.figure(figsize=(3,2.25), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(PSD)</span>
<span class="sd">    &gt;&gt;&gt; cbar=plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; cbar.set_label(&#39;occupied (type)&#39;, rotation=90, labelpad=10, y=0.5)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; fig=plt.figure(figsize=(3,2.25), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(NN)</span>
<span class="sd">    &gt;&gt;&gt; cbar=plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; cbar.set_label(&#39;nearest neighbours&#39;, rotation=90, labelpad=10, y=0.5)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; fig=plt.figure(figsize=(3,2.25), dpi=150)</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(sm.kUBcoop(kUB, NN, PSD))</span>
<span class="sd">    &gt;&gt;&gt; cbar=plt.colorbar()</span>
<span class="sd">    &gt;&gt;&gt; cbar.set_label(&#39;binding rate $k_{UB}^{coop}$&#39;, rotation=90, labelpad=10, y=0.5)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;position&#39;)</span>

<span class="sd">    Output:</span>
<span class="sd">        </span>
<span class="sd">    .. image:: images/example1_kUBcoop.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    .. image:: images/example2_kUBcoop.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    .. image:: images/example3_kUBcoop.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    .. image:: images/example4_kUBcoop.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">M</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">PSD</span><span class="p">))</span>
    <span class="n">free</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">PSD</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">Chi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span>
    <span class="n">M</span><span class="p">[</span><span class="n">free</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="n">kUB</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">Chi</span><span class="o">+</span><span class="mi">1</span><span class="p">))[</span><span class="n">NN</span><span class="p">])[</span><span class="n">free</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">M</span></div>






<div class="viewcode-block" id="probabilityEval"><a class="viewcode-back" href="../../code.html#ampartrafficking.stochastic_model.probabilityEval">[docs]</a><span class="k">def</span> <span class="nf">probabilityEval</span><span class="p">(</span><span class="n">Mub</span><span class="p">,</span><span class="n">Mbu</span><span class="p">,</span><span class="n">PSD</span><span class="p">,</span><span class="n">ID_basal</span><span class="p">,</span><span class="n">Mub_notBleached</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">Mbu_notBleached</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ID_notBleached</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;Returns the updated PSD Matrix and the corresponding number of receptors that got bound and unbound. To types, &quot;basal&quot; and &quot;not bleached&quot; can be considered, which is necessary when simulation FRAP.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Mub : array_like</span>
<span class="sd">        Matrix containing binding probabilities for the type &quot;basal&quot;.</span>
<span class="sd">    Mbu : array_like</span>
<span class="sd">        Matrix containing unbinding probabilities for the type &quot;basal&quot;.</span>
<span class="sd">    Mub_notBleached : array_like, optional</span>
<span class="sd">        By default None. Matrix containing binding probabilities for the type &quot;not bleached&quot;.</span>
<span class="sd">    Mbu_notBleached : array_like, optional</span>
<span class="sd">        By default None. Matrix containing unbinding probabilities for the type &quot;not bleached&quot;.</span>
<span class="sd">    PSD : array_like</span>
<span class="sd">        Matrix representing the PSD grid and its bound receptors.</span>
<span class="sd">    ID_basal : float</span>
<span class="sd">        Receptor ID of the basal pool.</span>
<span class="sd">    ID_notBleached: float</span>
<span class="sd">        Receptor ID of the not bleached pool.</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: float, float, float, float, array_like</span>
<span class="sd">        Number of receptors that got bound and unbound of the two types &quot;basal&quot; and &quot;not bleached&quot; and the updated PSD matrix.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    </span>
<span class="sd">    Import libraries:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; import ampartrafficking.stochastic_model as sm</span>
<span class="sd">    </span>
<span class="sd">    Set parameters:</span>

<span class="sd">    &gt;&gt;&gt; U=10</span>
<span class="sd">    &gt;&gt;&gt; U_notBleached=10</span>
<span class="sd">    &gt;&gt;&gt; kUB=0.005</span>
<span class="sd">    &gt;&gt;&gt; kBU=1</span>
<span class="sd">    &gt;&gt;&gt; N=10</span>
<span class="sd">    &gt;&gt;&gt; ID_basal=1</span>
<span class="sd">    &gt;&gt;&gt; ID_notBleached=2</span>
<span class="sd">    &gt;&gt;&gt; dt=0.5</span>
<span class="sd">    </span>
<span class="sd">    Create and populate grid and calculate nearest neighbour matrix:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; PSD=np.zeros((N,N))</span>
<span class="sd">    &gt;&gt;&gt; while np.sum(PSD)&lt;20*ID_basal:</span>
<span class="sd">    &gt;&gt;&gt;     i=np.random.randint(0,N)</span>
<span class="sd">    &gt;&gt;&gt;     j=np.random.randint(0,N)</span>
<span class="sd">    &gt;&gt;&gt;     if PSD[i,j]==0:</span>
<span class="sd">    &gt;&gt;&gt;         PSD[i,j]=ID_basal</span>
<span class="sd">    &gt;&gt;&gt;         </span>
<span class="sd">    &gt;&gt;&gt; while np.sum(PSD)&lt;20*ID_basal+20*ID_notBleached:</span>
<span class="sd">    &gt;&gt;&gt;     i=np.random.randint(0,N)</span>
<span class="sd">    &gt;&gt;&gt;     j=np.random.randint(0,N)</span>
<span class="sd">    &gt;&gt;&gt;     if PSD[i,j]==0:</span>
<span class="sd">    &gt;&gt;&gt;         PSD[i,j]=ID_notBleached</span>
<span class="sd">    &gt;&gt;&gt;         </span>
<span class="sd">    &gt;&gt;&gt; NN=sm.nearestNeighbours(PSD)</span>
<span class="sd">    </span>
<span class="sd">    Plot PSD:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(PSD)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    </span>
<span class="sd">    Calculate probability Matrices and update the PSD Matrix:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; Mbu=sm.kBUcoop(kBU, NN, PSD, ID_basal)*dt</span>
<span class="sd">    &gt;&gt;&gt; Mub=sm.kUBcoop(kUB*U, NN, PSD)*dt</span>
<span class="sd">    &gt;&gt;&gt; Mbu_notBleached=sm.kBUcoop(kBU, NN, PSD, ID_notBleached)*dt</span>
<span class="sd">    &gt;&gt;&gt; Mub_notBleached=sm.kUBcoop(kUB*U_notBleached, NN, PSD)*dt</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; PSD,dBoff,dBon,dBoff_notBleached,dBon_notBleached=sm.probabilityEval(Mub,Mbu,PSD,ID_basal,Mub_notBleached,Mbu_notBleached,ID_notBleached)</span>

<span class="sd">    Plot PSD:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; plt.figure()</span>
<span class="sd">    &gt;&gt;&gt; plt.imshow(PSD)</span>
<span class="sd">    &gt;&gt;&gt; plt.colorbar()</span>
<span class="sd">    </span>
<span class="sd">    Output: (left: before, right: after)</span>
<span class="sd">        </span>
<span class="sd">    .. image:: images/example1_probabilityEval.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    .. image:: images/example2_probabilityEval.png</span>
<span class="sd">        :width: 45%</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    
    <span class="n">n</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">PSD</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">m</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">PSD</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
    <span class="n">Mask_ub</span><span class="o">=</span><span class="n">R</span><span class="o">&lt;</span><span class="n">Mub</span>
    <span class="n">Mask_bu</span><span class="o">=</span><span class="n">R</span><span class="o">&lt;</span><span class="n">Mbu</span>
    
    <span class="k">if</span> <span class="n">Mub_notBleached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">R</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
        <span class="n">Mask_ub_notBleached</span><span class="o">=</span><span class="n">R</span><span class="o">&lt;</span><span class="n">Mub_notBleached</span>
        <span class="n">Mask_bu_notBleached</span><span class="o">=</span><span class="n">R</span><span class="o">&lt;</span><span class="n">Mbu_notBleached</span>

    
    <span class="k">if</span> <span class="n">Mub_notBleached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">R2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">)</span>
        <span class="n">ii_basal</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">Mask_ub</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Mask_ub_notBleached</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">R2</span><span class="o">&lt;</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">ii_notBleached</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">Mask_ub</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">Mask_ub_notBleached</span><span class="o">==</span><span class="kc">True</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">R2</span><span class="o">&gt;=</span><span class="mf">0.5</span><span class="p">))</span>
        <span class="n">Mask_ub</span><span class="p">[</span><span class="n">ii_basal</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
        <span class="n">Mask_ub_notBleached</span><span class="p">[</span><span class="n">ii_notBleached</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
    
    
    <span class="n">dBoff</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mask_bu</span><span class="p">)</span>
    <span class="n">dBon</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mask_ub</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">Mub_notBleached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dBoff_notBleached</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mask_bu_notBleached</span><span class="p">)</span>
        <span class="n">dBon_notBleached</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Mask_ub_notBleached</span><span class="p">)</span>

    
    <span class="n">PSD</span><span class="p">[</span><span class="n">Mask_ub</span><span class="p">]</span><span class="o">=</span><span class="n">ID_basal</span>
    <span class="n">PSD</span><span class="p">[</span><span class="n">Mask_bu</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">Mub_notBleached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">PSD</span><span class="p">[</span><span class="n">Mask_ub_notBleached</span><span class="p">]</span><span class="o">=</span><span class="n">ID_notBleached</span>
        <span class="n">PSD</span><span class="p">[</span><span class="n">Mask_bu_notBleached</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    
    
    <span class="k">if</span> <span class="n">Mub_notBleached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PSD</span><span class="p">,</span><span class="n">dBoff</span><span class="p">,</span> <span class="n">dBon</span><span class="p">,</span> <span class="n">dBoff_notBleached</span><span class="p">,</span> <span class="n">dBon_notBleached</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">PSD</span><span class="p">,</span><span class="n">dBoff</span><span class="p">,</span> <span class="n">dBon</span></div>
    






<div class="viewcode-block" id="update_mobilePool"><a class="viewcode-back" href="../../code.html#ampartrafficking.stochastic_model.update_mobilePool">[docs]</a><span class="k">def</span> <span class="nf">update_mobilePool</span><span class="p">(</span><span class="n">U</span><span class="p">,</span><span class="n">pin</span><span class="p">,</span><span class="n">pout</span><span class="p">,</span><span class="n">dBoff</span><span class="p">,</span><span class="n">dBon</span><span class="p">,</span> <span class="n">U_notBleached</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">pin_notBleached</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">pout_notBleached</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dBoff_notBleached</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dBon_notBleached</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Updates the value for the mobile receptor pool. When simulating FRAP, a second type &quot;not bleached&quot; is considered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    U : float</span>
<span class="sd">        Mobile AMPAR pool.</span>
<span class="sd">    pin : float</span>
<span class="sd">        Probability of a receptor to enter the spine&#39;s mobile pool.</span>
<span class="sd">    pout : float</span>
<span class="sd">        Probability of a receptor to leave the spine&#39;s mobile pool.</span>
<span class="sd">    dBoff : float</span>
<span class="sd">        Number of receptors that got unbound from the PSD grid.</span>
<span class="sd">    dBon : float</span>
<span class="sd">        Number of receptors that got bound to the PSD grid.</span>
<span class="sd">    U_notBleached : float, optional</span>
<span class="sd">        Mobile AMPAR pool (bleached).</span>
<span class="sd">    pin_notBleached : float, optional</span>
<span class="sd">        Probability of a not bleached receptor to enter the spine&#39;s mobile pool.</span>
<span class="sd">    pout_notBleached : float, optional</span>
<span class="sd">        Probability of a not bleached receptor to enter the spine&#39;s mobile pool.</span>
<span class="sd">    dBoff_notBleached : float, optional</span>
<span class="sd">        Number of not bleached receptors that got unbound from the PSD grid.</span>
<span class="sd">    dBon_notBleached : float, optional</span>
<span class="sd">        Number of not bleached receptors that got bound to the PSD grid.</span>
<span class="sd">        </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: float, float</span>
<span class="sd">        U, U_notBleached.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">&lt;</span><span class="n">pin</span><span class="p">:</span>
        <span class="n">U</span><span class="o">+=</span><span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">U_notBleached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">&lt;</span><span class="n">pin_notBleached</span><span class="p">:</span>
            <span class="n">U_notBleached</span><span class="o">+=</span><span class="mi">1</span>
        
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">&lt;</span><span class="n">pout</span><span class="p">:</span>
        <span class="n">U</span><span class="o">-=</span><span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">U_notBleached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span><span class="o">&lt;</span><span class="n">pout_notBleached</span><span class="p">:</span>
            <span class="n">U_notBleached</span><span class="o">-=</span><span class="mi">1</span>

    <span class="n">DeltaB</span><span class="o">=</span><span class="n">dBoff</span><span class="o">-</span><span class="n">dBon</span>
    <span class="n">U</span><span class="o">+=</span><span class="n">DeltaB</span>

    <span class="k">if</span> <span class="n">U_notBleached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">DeltaB_notBleached</span><span class="o">=</span><span class="n">dBoff_notBleached</span><span class="o">-</span><span class="n">dBon_notBleached</span>
        <span class="n">U_notBleached</span><span class="o">+=</span><span class="n">DeltaB_notBleached</span>

    <span class="k">if</span> <span class="n">U</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">U</span><span class="o">=</span><span class="mi">0</span>
        
    <span class="k">if</span> <span class="n">U_notBleached</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">U_notBleached</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">U_notBleached</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">return</span> <span class="n">U</span><span class="p">,</span> <span class="n">U_notBleached</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">U</span></div>
        
    
    
<div class="viewcode-block" id="calcTimeStep"><a class="viewcode-back" href="../../code.html#ampartrafficking.stochastic_model.calcTimeStep">[docs]</a><span class="k">def</span> <span class="nf">calcTimeStep</span><span class="p">(</span><span class="n">UFP_0</span><span class="p">,</span><span class="n">A_spine</span><span class="p">,</span><span class="n">kUB</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">kBU</span><span class="p">,</span><span class="n">kout</span><span class="p">,</span><span class="n">kin</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Returns integration time step dt. By default simulations are carried out at dt=0.5s. If parameter choices require a smaller time step, dt is set to 0.25s. If dt is still too large, the simulation is cancelled and an error message is displayed. In this case dt needs to be set manually.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    UFP_0 : float</span>
<span class="sd">        Mobile receptor pool fixed points. Sets the influx of receptors into spine. </span>
<span class="sd">    A_spine : float</span>
<span class="sd">        Spine surface area. </span>
<span class="sd">    kUB : float</span>
<span class="sd">        bidning rate</span>
<span class="sd">    alpha : float</span>
<span class="sd">        cooperativity factor for the binding</span>
<span class="sd">    kBU : float</span>
<span class="sd">        unbidning rate</span>
<span class="sd">    kout : float</span>
<span class="sd">        Total rate at which receptors exit the spine membrane (e.g. kout+kendo).</span>
<span class="sd">    kin : float</span>
<span class="sd">        Total rate at which receptors enter the spine membrane (e.g. kexo*Sexo+kin).</span>
<span class="sd">    </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    float</span>
<span class="sd">        Integration time step dt. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">dt</span><span class="o">=</span><span class="mf">0.5</span>
    <span class="n">thr</span><span class="o">=</span><span class="mf">0.5</span> 
    <span class="c1">#Note that a threshold for the probability of 0.5 (thr) is rather high.</span>
    <span class="c1">#However, it turned out to be sufficient for the current study. </span>
    <span class="c1">#Also, below, the probabilities are calculated for values of U twice </span>
    <span class="c1">#the fixed point (2*UFP_0) to account for fluctuations in U that are above the fixed point value. </span>
    
    <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">kUB</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span> <span class="ow">or</span> <span class="n">kBU</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span> <span class="ow">or</span> <span class="n">kout</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span> <span class="ow">or</span> <span class="n">kin</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span><span class="p">:</span>
        <span class="n">dt</span><span class="o">=</span><span class="mf">0.25</span>

    <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">kUB</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span> <span class="ow">or</span> <span class="n">kBU</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span> <span class="ow">or</span> <span class="n">kout</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span> <span class="ow">or</span> <span class="n">kin</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span><span class="p">:</span>
        <span class="n">dt</span><span class="o">=</span><span class="mf">0.1</span>

    <span class="k">if</span> <span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">kUB</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span> <span class="ow">or</span> <span class="n">kBU</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span> <span class="ow">or</span> <span class="n">kout</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span> <span class="ow">or</span> <span class="n">kin</span><span class="o">*</span><span class="n">dt</span><span class="o">&gt;</span><span class="n">thr</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Errors, Integration time step dt is too large!&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s2">&quot;Errors, Integration time step dt is too large!&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dt=&#39;</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span> <span class="s1">&#39;pmax=&#39;</span><span class="p">,</span> <span class="nb">max</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">kUB</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">kBU</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">kout</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">kin</span><span class="o">*</span><span class="n">dt</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pUB=&#39;</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">kUB</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pBU=&#39;</span><span class="p">,</span><span class="n">kBU</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pin=&#39;</span><span class="p">,</span><span class="n">kin</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pout=&#39;</span><span class="p">,</span><span class="n">kout</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">UFP_0</span><span class="o">/</span><span class="n">A_spine</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">dt</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Moritz F P Becker

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>